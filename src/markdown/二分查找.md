* [二分查找](#二分查找)
   * [33 搜索旋转排序数组](#搜索旋转排序数组)
   * [69 x 的平方根](#x的平方根)
   * [74 搜索二维矩阵](#搜索二维矩阵)
   * [153 寻找旋转排序数组中的最小值](#寻找旋转排序数组中的最小值)
   * [367 有效的完全平方数](#有效的完全平方数)

## 二分查找
* 二分查找也叫做折半查找，它是一种效率较高的查找方法，可以在时间复杂度O（n）内完成查找。
* 主要应用于有序的数组查找，或者部分有序的数组查找。
* 体现的思想是【减而治之】，通过求解中间元素，和目标值做比较，再缩小范围，直到查到目标值。

## 二分查找例子

## 搜索旋转排序数组

### 题目描述
![image](https://user-images.githubusercontent.com/11553237/133453669-df153a3a-8637-49ed-8c13-b982bd97f22f.png)

### 解题思路
![image](https://user-images.githubusercontent.com/11553237/133454494-b9576f0a-2593-477b-bcc7-35e15e83b798.png)

* 对于有序数组，可以使用二分查找。本题的数组并不是有序的，但也是分成两部分有序。
* 从上图可以发现，将数组分成左右两部分的时候，一定是有一部分的数组是有序的，上图的左部分从6这个位置分开以后变成[4,5,6]和[7,0,1,2]两个部分，左边的是有序的。上图的右部分是右边有序。
* 可以使用二分查找查看由 mid 分割出来的两部分 [l,mid] 和 [mid+1,r] 哪个部分是有序的，并根据有序的那个部分确定二分查找的左右边界
  * 如果[l,m-1]是有序数组，并且 target 的大小在 [l,mid] 中，则将搜索目标缩小至[l,mid - 1],否则范围在 [mid + 1，r] 中寻找。
  * 如果[mid,r]是有序数组，并且 target 的大小在 [mid + 1,r] 中，则将搜索目标缩小至[mid + 1,r],否则在[l,mid - 1] 中寻找。 

```
public int search(int[] nums, int target) {
    int length = nums.length;
    if (length == 0) {
        return -1;
    }
    if (length == 1) {
        return nums[0] == target ? 0 : -1;
    }
    int left = 0,right = length-1;
    while (left <= right) {
        int mid = left + (right - left)/2;
        if (nums[mid] == target) {
            return mid;
        }
        if (nums[0] <= nums[mid]) {
            if (nums[0] <= target && target < nums[mid]) {
                right = mid -1;
            } else {
                left = mid + 1;
            }
        } else {
            if (nums[mid] < target && target <= nums[length - 1]) {
                 left = mid + 1;
            } else {
                 right = mid - 1;
            }
        }
    }
    return -1;
}

```

## x的平方根
### 题目描述
![image](https://user-images.githubusercontent.com/11553237/133540023-09218358-464a-4656-b17b-27bef4e13890.png)

### 解题思路
* 返回的结果只返回整数，平方根的整数部分满足k² <= x，需要获取 k 的最大值，所以要对k进行二分查找。
* 左边界是0，右边界是为x，每次二分查找到中间值 mid，mid 的平方的 x 的大小做对比。
  * 如果 mid 的平方小于等于 x，赋值结果，并且左边界移动到 mid + 1 的位置。
  * 如果 mid 的平方大于x，将有边界移动到 mid - 1 的位置。

```
public int mySqrt(int x) {
    //二分查找
    if (x == 0 || x == 1) {
        return x;
    }
    int left = 1;
    int right = x;
    int result = -1;
    while (left <= right) {
        int mid = left + (right - left)/2;
        if ((long)mid * mid > x) {
            right = mid - 1;
        } else {	
            result = mid;
            left = mid + 1;
        }

    }
    return result;

}

```


## 搜索二维矩阵

### 题目描述
![image](https://user-images.githubusercontent.com/11553237/133532155-d8d7dca3-f572-4924-a80a-73f61ec9efee.png)

### 解题思路
* 每一行都是升序排列，每一行的第一个整数都大于最后一个整数。将每一行拼接上一行，可以组成一个新的升序数组
* 新的升序数组可以使用二分查找，查找是否有目标值。
* 新数组是一个虚拟的数组，新数组的下标[mid/n,mid%n]。

```
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;
        int left = 0;
        int right = m * n - 1;
        while (left <= right) {
            int mid = left + (right - left)/2;
            int midValue = matrix[mid/n][mid%n];
            if (target < midValue) {
                right = mid - 1;
            }else if (target > midValue) {
                left = mid + 1;
            } else {
                return true;
            }
        }
	return false;
    }
}
```

## 寻找旋转排序数组中的最小值
### 题目描述
![image](https://user-images.githubusercontent.com/11553237/133534980-8fbd7150-7f8b-414a-8a19-eb08805adbcd.png)

### 解题思路
* 旋转数组是要么全部有序，要么两个部分有序。
* 每次做二分查找，每次mid和最右边值作比较，会出现两种情况。
![image](https://user-images.githubusercontent.com/11553237/133537152-e301094d-e573-46b3-baec-6ef8690d14ee.png)	
   * 第一种情况是 nums[pivot] < nums[high]，如上图所示，此时最小值应该在piot的左侧，height 缩进到 pivot 的位置。
![image](https://user-images.githubusercontent.com/11553237/133537382-082a5373-7e86-43d8-8e09-b28ee12e4605.png)
   * 第二种情况是 nums[piot] > num[height], 如上图所示，此时最小值应该在piot的右侧，low 缩进到 piot 的位置。

```
class Solution {
    public int findMin(int[] nums) {
        int low = 0,height = nums.length-1;
	    while (low < height) {
            int mid = low + (height - low)/2;
            if (nums[mid] < nums[height]) {
                height = mid;
            } else {
                low = mid + 1;
            }
        }
	    return nums[low];
    }
}
```

## 有效的完全平方数
### 题目描述
![image](https://user-images.githubusercontent.com/11553237/133556149-693e9336-2f7d-4ad3-b196-623044cde2fb.png)
### 解题思路
* 判断一个数是否是完全平方数，需要找到他的开根数。
* 使用二分法查找，如果 num < 2 返回true。
* 设置left为2，right为num。
* 每次找到中间值mid = left + (right - left)/2。
  * 如果 mid² = num，返回true。
  * 如果 mid² < num,left = mid + 1。
  * 如果 mid² > num ,right = mid - 1。

```
public boolean isPerfectSquare(int num) {
    if (num <= 2) {
        return true;
    }
    int left = 2,right = num/2,y;
    long square;
    while (left <= right) {
        y = left + (right - left)/2;
        square =(long) y * y;
        if (square == num) {
            return true;
        }else if (square > num) {
            right = y - 1;
        }else {
            left = y + 1;
        }
    }
    return false;
}
```







