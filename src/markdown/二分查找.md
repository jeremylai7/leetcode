* [二分查找](#二分查找)
   * [33 搜索旋转排序数组](#搜索旋转排序数组)
   * [74 搜索二维矩阵](#搜索二维矩阵)
   * [153 寻找旋转排序数组中的最小值]()

## 二分查找
* 二分查找也叫做折半查找，它是一种效率较高的查找方法，可以在时间复杂度O（n）内完成查找。
* 主要应用于有序的数组查找，或者部分有序的数组查找。
* 体现的思想是【减而治之】，通过求解中间元素，和目标值做比较，再缩小范围，直到查到目标值。

## 二分查找例子

## 搜索旋转排序数组

### 题目描述
![image](https://user-images.githubusercontent.com/11553237/133453669-df153a3a-8637-49ed-8c13-b982bd97f22f.png)

### 解题思路
![image](https://user-images.githubusercontent.com/11553237/133454494-b9576f0a-2593-477b-bcc7-35e15e83b798.png)

* 对于有序数组，可以使用二分查找。本题的数组并不是有序的，但也是分成两部分有序。
* 从上图可以发现，将数组分成左右两部分的时候，一定是有一部分的数组是有序的，上图的左部分从6这个位置分开以后变成[4,5,6]和[7,0,1,2]两个部分，左边的是有序的。上图的右部分是右边有序。
* 可以使用二分查找查看由 mid 分割出来的两部分 [l,mid] 和 [mid+1,r] 哪个部分是有序的，并根据有序的那个部分确定二分查找的左右边界
  * 如果[l,m-1]是有序数组，并且 target 的大小在 [l,mid] 中，则将搜索目标缩小至[l,mid - 1],否则范围在 [mid + 1，r] 中寻找。
  * 如果[mid,r]是有序数组，并且 target 的大小在 [mid + 1,r] 中，则将搜索目标缩小至[mid + 1,r],否则在[l,mid - 1] 中寻找。 

```
public int search(int[] nums, int target) {
    int length = nums.length;
    if (length == 0) {
        return -1;
    }
    if (length == 1) {
        return nums[0] == target ? 0 : -1;
    }
    int left = 0,right = length-1;
    while (left <= right) {
        int mid = left + (right - left)/2;
        if (nums[mid] == target) {
            return mid;
        }
        if (nums[0] <= nums[mid]) {
            if (nums[0] <= target && target < nums[mid]) {
                right = mid -1;
            } else {
                left = mid + 1;
            }
        } else {
            if (nums[mid] < target && target <= nums[length - 1]) {
                 left = mid + 1;
            } else {
                 right = mid - 1;
            }
        }
    }
    return -1;
}

```

## 搜索二维矩阵

### 题目描述
![image](https://user-images.githubusercontent.com/11553237/133532155-d8d7dca3-f572-4924-a80a-73f61ec9efee.png)

### 解题思路
* 每一行都是升序排列，每一行的第一个整数都大于最后一个整数。将每一行拼接上一行，可以组成一个新的升序数组
* 新的升序数组可以使用二分查找，查找是否有目标值。
* 

```
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;
        int left = 0;
        int right = m * n - 1;
        while (left <= right) {
            int mid = left + (right - left)/2;
            int midValue = matrix[mid/n][mid%n];
            if (target < midValue) {
                right = mid - 1;
            }else if (target > midValue) {
                left = mid + 1;
            } else {
                return true;
            }
        }
	    return false;
    }
}
```









