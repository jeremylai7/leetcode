* [链表](#链表)
    * [206 反转链表](#反转链表)
    * [19 删除链表的倒数第N个结点](#删除链表的倒数第N个结点)
    * [141 环形链表](#环形链表)
    * [21 合并两个有序链表](#合并两个有序链表)

### 链表
概念: 
* 区别于数组，链表中的元素不是存储在内存中连续的一片区域，链表中的数据存储在每一个称之为「结点」复合区域里，在每一个结点除了存储数据以外，还保存了到下一个结点的指针（Pointer）。

![image](https://user-images.githubusercontent.com/11553237/131843264-90ac32ca-643d-4701-90cc-1ace9f2050f0.png)

* 由于不必按顺序存储，链表在插入数据的时候可以达到 O(1)O(1) 的复杂度，但是查找一个结点或者访问特定编号的结点则需要 O(n)O(n) 的时间。

### 链表例子

#### 反转链表
##### 题目描述
![image](https://user-images.githubusercontent.com/11553237/131843538-53b60e9a-a189-4f20-a238-0f02c26aa312.png)
##### 解法
* 设置一个空链表pre
* 遍历链表，每次先将链表的next，赋值给一个新的链表。
* 链表的next指向pre。
* 当前链表赋值给pre。
* 继续遍历next链表
```
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode cur = head;
        ListNode pre = null;
        while(cur != null) {
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next; 
        }
        return pre;

    }
}
```


#### 删除链表的倒数第N个结点

##### 题目描述

![image](https://user-images.githubusercontent.com/11553237/131985085-7b08d786-e2c0-4267-b9f1-9859132a9365.png)

##### 解法
* 从头遍历一遍链表，得到链表的长度L。
* 再次遍历链表，当遍历到L-n+1的位置就是要删除的结点。
* 删除L-n +1 的位置找到前一个位置 L-n,将 L-n 的next指向next.next。
* 要删除结点如果是链表的第一个结点，就找不到第一个结点的上一个结点，所以需要创建一个伪结点dummy，执行链表。删除结点后，返回dummy.next结点。

```
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode cur = head;
		int length = 0;
		while(cur != null) {
			cur = cur.next;
			length++;
		}
		int index = 1;
		int sub = length - n + 1;
		ListNode dummy = new ListNode(1,head);
		cur = dummy;
		while(cur != null) {
			if(index == sub) {
				cur.next = cur.next.next;
				break;
			}
			cur = cur.next;
			index++;
		}
		return dummy.next;
    }
}

```

#### 环形链表
##### 题目描述

![image](https://user-images.githubusercontent.com/11553237/132037638-b1576681-241e-44ad-b0d8-aeaa0e63c277.png)

#### 解法
* 使用hash表，每次遍历存储结点，使用hash表存储遍历的结点。
* 遍历的结点在hash表中存在时，则说明链表是环形链表。

```
public class Solution {
    public boolean hasCycle(ListNode head) {
        Set<ListNode> set = new HashSet<>();
		while (head != null) {
			if (!set.add(head)) {
				return true;
			}
			head = head.next;
		}
        return false;
    }
}
```



